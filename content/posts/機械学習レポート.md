---
title: "機械学習レポート"
date: 2021-06-12T01:18:19+09:00
draft: false
mathjax: true
---
[1.線形回帰モデル](#線形回帰モデル)

[2.非線形回帰モデル](#非線形回帰モデル)

[3.ロジスティック回帰モデル](#ロジスティック回帰モデル)

[4.主成分分析](#主成分分析)

[5.アルゴリズム](#アルゴリズム)

[6.サポートベクタマシン](#サポートベクタマシン)


# 線形回帰モデル

<講義内容サマリ>
### 回帰問題
回帰モデルではある入力値（離散あるいは連続）から出力値（連続）を予測する問題であり、線形関数（直線）で予測するものを線形回帰（単回帰）という。
* 回帰で扱うデータ
  * 入力値（各要素を説明変数または特徴量と呼ぶ）
     * m次元ベクトル（m=1の場合はスカラー） 
  * 出力値（目的変数）
     * スカラー値（目的変数）

**入力値（説明変数）**
`$$
\begin{eqnarray*}
\boldsymbol{x} &=& (x_1, x_2, \cdots, x_m)^{T} \\
\end{eqnarray*}
$$`

**出力値（目的変数）**
`$$
\begin{eqnarray*}
y \in \mathbb{R}^m \\
\end{eqnarray*}
$$`

### 線形回帰モデルとは
線形回帰モデルとは、機械学習モデルの一つであり、教師あり学習の回帰手法である。
入力値に対して$m$次元パラメータの線型結合を出力するモデルである。
パラメータとは、モデルに含まれる推定すべき未知のパラメータであり、特徴量が予測値に対してどのように影響を与えるかを決定する重み値の集合である。
線形回帰モデルでは、この未知のパラメータに対して、最小二乗法により推定する。

**パラメータ**
`$$
\begin{eqnarray*}
\boldsymbol{w} &=& (w_1, w_2, \cdots, w_m)^{T} \in \mathbb{R}^m \\
\end{eqnarray*}
$$`

**線型結合**
`$$
\begin{eqnarray*}
 \hat{y} = \boldsymbol{w}^T \boldsymbol{x} + w_0 = \sum^{m}_{j=1} w_j x_j + w_0 \\
\end{eqnarray*}
$$`

### データの分割とモデルの汎化性能測定
教師用データについて、学習用データと検証用データにそれぞれ分割する。モデルの汎化性能（Generalization）を測定するためで、データへの当てはまりの良さではなく、未知のインプットデータに対しての精度の高さを測定する。
* 学習用データ：機械学習モデルの学習に利用するデータ
* 検証用データ：学習済みモデルの制度を検証するためのデータ

### 線形回帰モデルパラメータの推定
モデルパラメータの推定は、以下の平均二乗誤差MSE$_{train}$（残渣平方和：データとモデル出力の二乗誤差の和）を最小化するパラメータを探索する。
`$$
\begin{eqnarray*}
 \rm{MSE}_{train} = \frac{1}{n_{train}} \sum^{n_{train}}_{i=1} (\hat{y}^{(train)}_i - y^{(train)}_i)^2 \\ 
\end{eqnarray*}
$$`

MSEを最小とするような$w$を求めるため、以下の方程式を解く。
\begin{eqnarray*}
 \frac{\partial}{\partial w}\rm{MST_{train}} = 0 \\
\end{eqnarray*}
左辺について行列変形を実施する。
`
\begin{eqnarray*}
 \frac{\partial}{\partial w}\rm{MST_{train}} &=&  \frac{\partial}{\partial w} \left(\frac{1}{n_{\rm{train}}} \sum^{n_{\rm{(train)}}}_{i=1} \left(\hat{y}^{\rm{(train)}}_i - y^{\rm{(train)}}_i\right)^2 \right) \\
&=& \frac{\partial}{\partial \boldsymbol{w}} \left( \left(X^{n_{\rm{(train)}}} \boldsymbol{w} - \boldsymbol{y}^{(\rm{train})} \right)^T \left(X^{n_{\rm{(train)}}} \boldsymbol{w} - \boldsymbol{y}^{(\rm{(train)})} \right) \right) \\
&=& 0  \\
\end{eqnarray*}
`
これを解くと以下の回帰係数の式が得られる。
* 回帰係数
\begin{eqnarray*}
 \boldsymbol{\hat{w}} &=& \left({X^{\rm{(train)}}}^{T} X^{\rm{(train)}}\right)^{-1} {X^{\rm{(train)}}}^{T} \boldsymbol{y}^{\rm{(train)}} \\
\end{eqnarray*}

* 予測値
\begin{eqnarray*}
 \boldsymbol{\hat{y}} &=& X\left({X^{\rm{(train)}}}^{T} X^{\rm{(train)}}\right)^{-1} {X^{\rm{(train)}}}^{T} \boldsymbol{y}^{\rm{(train)}} \\
\end{eqnarray*}


<実装演習結果>
ボストンの家賃価格に関する統計情報を元に、線形回帰モデルの演習を実施する。
今回は、部屋数と家賃との関係性に着目して、線形回帰モデルにてフィッティングを実施する。
```python
from sklearn.datasets import load_boston
from pandas import DataFrame
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot  as plt

boston = load_boston()

df = DataFrame(data=boston.data ,columns = boston.feature_names)
# 目的変数をDataFrameへ追加
df['PRICE'] = np.array(boston.target)

data = df.loc[:, ['RM']].values
target = df.loc[:, ['PRICE']].values

#線形回帰モデルにてフィッティングを実行
model = LinearRegression()
model.fit(data, target)
```
Room数が3部屋だった場合の家賃を予想する。
```python
model.predict([[3]])
```
array([[-7.36429383]])

部屋数と家賃価格との関係性をプロットする。
```python
plt.scatter(data,target)
plt.plot(data, model.predict(data), color = 'red')
```
{{< figure src="/image/lin_fit.png" title="部屋数に対する家賃価格のプロットと線形回帰結果" class="center" width="550" height="350" >}}



# 非線形回帰モデル

<講義内容サマリ>

線形回帰で実現できないような複雑な非線形構造を内在する現象に対して、非線形回帰モデリングを実施する。
非線形回帰モデルでは、回帰関数として基底関数と呼ばれる既知の非線形関数とパラメータベクトルの線型結合を使用する。未知パラメータは線形回帰モデルと応用に最小二乗法や最尤法によって推定する。
基底展開法も線形回帰と同じ枠組みで推定可能である。

\begin{eqnarray*}
 y_i = w_0 + \sum^{m}_{j=1} w_j \phi_j (\boldsymbol{x}_i) + \epsilon_i \\
\end{eqnarray*}

* よく使われる基底関数
  * 多項式関数
  * ガウス型基底関数
  * スプライン関数/Bスプライン関数

説明変数
\begin{eqnarray*}
 x_i = (x_{i1},x_{i2},\cdots, x_{im}) \in \mathbb{R}^m \\
\end{eqnarray*}
非線形関数ベクトル
\begin{eqnarray*}
 \phi (\boldsymbol{x_i}) = (\phi_1(\boldsymbol{x}_i), \phi_2 (\boldsymbol{x}_i), \cdots, \phi_k (\boldsymbol{x}_i))^T \in \mathbb{R}^k \\
\end{eqnarray*}
非線形関数の計画行列
\begin{eqnarray*}
 \Phi^{(train)} = (\Phi (\boldsymbol{x}_1), \Phi (\boldsymbol{x}_2), \cdots, \Phi (\boldsymbol{x}_n))^T \in \mathbb{R}^{n \times k} \\
\end{eqnarray*}
最尤法による予測値
\begin{eqnarray*}
 \hat{\boldsymbol{y}} = \Phi \left( \Phi^{(train)T} \Phi^{(train)} \right)^{-1} \Phi^{(train)T} \boldsymbol{y}^{(train)} \\
\end{eqnarray*}

#### 未学習（underfitting) と過学習 (overfitting)

* 学習データに対して、十分小さな誤差が得られないモデル$\rightarrow$未学習
  * （対策）モデルの表現力が低いため、表現力の高いモデルを利用する
* 小さな誤差は得られたけど、テスト集合誤差との差が大きいモデル$\rightarrow$過学習
  * (対策1) 学習データの数を増やす
  * (対策2) 不要な基底関数（変数）を削除して表現力を抑止
  * (対策3) 正則化法を利用して表現力を抑止

##### （対策2）不要な基底関数を削除する
* 基底関数の数、位置やバンド幅によるモデルの複雑さが変化する
* 解きたい問題に対して多くの基底関数を用意してしまうと過学習の問題が起こるため、適切な基底関数を用意する

##### （対策3）正則化法（罰則化法）
* 「モデルの複雑さに伴って、その値が大きくなる正則化項（罰則項）を課した関数」を最小化する
\begin{eqnarray*}
 S_{\gamma} = \left(\boldsymbol{y} - \Phi \boldsymbol{w}\right)^T \left( \boldsymbol{y} - \Phi \boldsymbol{w} \right) + \gamma R(\boldsymbol{w}) 
\end{eqnarray*}
基底関数の数kが増加するとパラメータが増加し、残渣が減少する（モデルが複雑化）。

* 正則化
  * L2ノルムを利用 $\rightarrow$ Ridge推定量
  * L1ノルムを利用 $\rightarrow$ Lasso推定量

#### 汎化性能
適切なモデル（汎化性能が高いモデル）は交差検証法にて決定する。汎化性能とは、学習に使用した入力だけではなく、これまで見たことのない新たな入力に対する予測性能のことである。

* 訓練性能
\begin{eqnarray*}
 MSE_{train} = \frac{1}{n_{train}} \sum^{n_{train}}_{i=1} \left( \hat{y}_i^{(train)} - y^{(train)}_i \right)^2 \\
\end{eqnarray*}
* テスト誤差
\begin{eqnarray*}
 MSE_{test} = \frac{1}{n_{test}} \sum^{n_{test}}_{i=1} \left( \hat{y}_i^{(test)} - y^{(test)}_i \right)^2 \\
\end{eqnarray*}

##### 未学習と過学習の見分け方
* 訓練誤差もテスト誤差もどちらも小さい$\rightarrow$汎化しているモデル
* 訓練誤差は小さいがテスト誤差が大きい$\rightarrow$過学習
* 訓練誤差もテスト誤差もどちらも小さくならない$\rightarrow$未学習

##### ホールドアウト法
* 有限のデータと学習用とテスト用の2つに分割し、「予測制度」や「誤り率」を推定するために使用する。
  * 学習用を多くすればテスト用が減り学習精度は良くなるが、性能評価の精度は悪くない
  * 逆にテスト用を多くすれば学習用が減少するので、学習そのものの精度が悪くなることになる
  * 手元にデータが大量にある場合を除いて、良い性能評価を与えないという欠点がある

#### グリッドサーチ
* 全てのチューニングパラメータの組み合わせで評価値を算出
* 最も良い評価値を持つチューイングパラメータを持つ組み合わせを「いいモデルのパラメータ」として採用する
`$$
\begin{eqnarray*}
 \boldsymbol{m} &=& (m_1, m_2, \cdots, m_c)^T \\
 \boldsymbol{\lambda} &=& (\lambda_1, \lambda_2, \cdots, \lambda_c)^T
\end{eqnarray*}
$$`

<実装演習結果>
```python
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

%matplotlib inline

#seaborn設定
sns.set()
#背景変更
sns.set_style("darkgrid", {'grid.linestyle': '--'})
#大きさ(スケール変更)
sns.set_context("paper")

n=100

def true_func(x):
    z = 1-48*x+218*x**2-315*x**3+145*x**4
    return z 

def linear_func(x):
    z = x
    return z # 真の関数からノイズを伴うデータを生成

# 真の関数からデータ生成
data = np.random.rand(n).astype(np.float32)
data = np.sort(data)
target = true_func(data)

# 　ノイズを加える
noise = 0.5 * np.random.randn(n) 
target = target  + noise

# ノイズ付きデータを描画

plt.scatter(data, target)

plt.title('NonLinear Regression')
plt.legend(loc=2)
```
KernelRidgeを使用して非線形関数でフィッティングを行う。
```python
from sklearn.kernel_ridge import KernelRidge

clf = KernelRidge(alpha=0.0002, kernel='rbf')
clf.fit(data, target)

p_kridge = clf.predict(data)

plt.scatter(data, target, color='blue', label='data')

plt.plot(data, p_kridge, color='orange', linestyle='-', linewidth=3, markersize=6, label='kernel ridge')
plt.legend()
#plt.plot(data, p, color='orange', marker='o', linestyle='-', linewidth=1, markersize=6)
```
{{< figure src="/image/hisenkei.png" title="非線形関数でのフィッティング結果" class="center" width="500" height="300" >}}



# ロジスティック回帰モデル

<講義内容サマリ>

ロジスティック線形回帰モデルは、分類問題を解くための教師あり機械学習モデルである。
入力と$m$次元パラメータの線型結合をシグモイド関数に入力する。シグモイド関数の出力値は0〜1の間をとり、その出力値は（クラス1）に分類される確率を表現している。
#### シグモイド関数
\begin{eqnarray*}
 \sigma (x) = \frac{1}{1 + \exp{(-ax)}}
\end{eqnarray*}

#### ロジスティック線形回帰モデル
データYは確率が0.5以上ならば1, 0.5未満ならば0と予測することで、分類問題を解決する。
\begin{eqnarray*}
 P(Y=1 | \boldsymbol{x}) = \sigma(w_0 + w_1 x_1 + \cdots + w_m x_m) \\ 
\end{eqnarray*}

#### 最尤推定
##### ベルヌーイ分布について
ベルヌーイ分布とは、数学において確率pで1, 確率(1-p)で0をとる離散確率分布である。
\begin{eqnarray*}
 P(y) = p^{y} (1-p)^{1-y} \\
\end{eqnarray*}

##### 尤度関数について
1回の試行において、$y=y_1$になる確率
\begin{eqnarray*}
  P(y) = p^{y} (1-p)^{1-y} \\ 
\end{eqnarray*}
n回の試行において$y_1$〜$y_n$が得られた場合、その出力結果から確率pを求める際に、尤度関数を最大化するようなパラメータ（確率p）を求める。このことを最尤推定という。
\begin{eqnarray*}
  P(y_1,y_2,\cdots, y_n;p) = \prod^{n}_{i=1} p^{y_i} (1-p)^{1-y_i} \\ 
\end{eqnarray*}

##### ロジスティック回帰モデルの最尤推定
確率pはシグモイド関数の出力結果となるため、推定するパラメータはシグモイド関数のインプットデータとなっている重みパラメータとなる。
尤度関数はパラメータのみに依存する関数のため、尤度関数を最大とするパラメータを探索する。
`$$
\begin{eqnarray*}
  P(y_1,y_2,\cdots, y_n|w_0,w_1, \cdots, w_m) &=& \prod^{n}_{i=1} p^{y_i} (1-p)^{1-y_i} \\ 
& = &  \prod^{n}_{i=1} \sigma (\boldsymbol{w}^T \boldsymbol{x}_i)^{y_i} (1- \sigma (\boldsymbol{w}^T \boldsymbol{x}_i))^{1-y_i} \\
& = & L (\boldsymbol{w}) \\
\end{eqnarray*}
$$`
* 尤度関数を最愛とするパラメータを探すために、尤度関数の対数をとり-1倍する。
  ** 対数を取ることで積和の変換がなされ、計算が簡単になる
  ** 桁落ちを防止する
  ** -1倍をすることで、最大化から最小化となり、最小二乗法と平仄を合わせている

`$$
\begin{eqnarray*}
 E (w_0,w_1, \cdots, w_m) &=& - \log L(w_0,w_1, \cdots, w_m) \\
&=& - \sum^{n}_{i=1} {y_i \log p_i + (1 - y_i) \log (1 - p_i)}\\ 
\end{eqnarray*}
$$`

##### 勾配降下法
ロジスティック回帰モデル（最尤法）では、対数尤度関数をパラメータで微分して0となる値を求める必要があるが、解析的にその値を求めることは困難である。そのため、パラメータに初期値を与え、パラメータを更新していき、勾配が0となった部分で最適な解が求められたことになる。
\begin{equation*}
 \boldsymbol{w}(k + 1) =  \boldsymbol{w}^k - \eta \frac{\partial E(\boldsymbol{w})}{\partial \boldsymbol {w}} \\
\end{equation*}
※勾配降下法では、パラメータを更新するのにN個全てのデータに対する和を計算する必要があるため、データ量が膨大となった際に処理時間の増加等の懸念がある。データ量が膨大な場合は、確率的勾配降下法を利用する。

##### 確率的勾配降下法（SGD）
データをランダムに選びパラメータを更新していく。勾配降下法にてパラメータを1回更新するのと同じ計算量でパラメータをn回更新できるため、効率よく最適な解を探索できる。
\begin{eqnarray*}
 \boldsymbol{w} (k + 1 ) = \boldsymbol{w}^k + \eta (y_i - p_i) \boldsymbol{x}_i \\
\end{eqnarray*}


<実装演習結果>

ロジスティック回帰の実習演習として、Kaggleが提供する「タイタニック号の生存者」に関するデータセットを用いて、ロジスティック回帰を実装した。

```python
#タイタニックデータセットのインポート
import pandas as pd
import numpy as np
from pandas import DataFrame
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
%matplotlib inline

train_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/機械学習/非線形回帰/train.csv")
test_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/機械学習/非線形回帰/test.csv")
```
データ欠損状況を確認して、欠損しているデータについては平均値で補間を実施する。
```python
#欠損状況の確認
def kesson_table(df): 
        null_val = df.isnull().sum()
        percent = 100 * df.isnull().sum()/len(df)
        kesson_table = pd.concat([null_val, percent], axis=1)
        kesson_table_ren_columns = kesson_table.rename(
        columns = {0 : '欠損数', 1 : '%'})
        return kesson_table_ren_columns
 
kesson_table(train_df)
kesson_table(test_df)
```
{{< figure src="/image/train_欠損.png" title="trainデータの欠損状況" class="center" width="200" height="300" >}}
{{< figure src="/image/test_欠損.png" title="testデータの欠損状況" class="center" width="200" height="300" >}}
```python
# Ageは説明変数へ利用するため、欠損については中央値で補完する。
#年齢の欠損値を男女の平均年齢で補間
age_train_mean = train_df.groupby('Sex').Age.mean()
def fillage(x):
    if x.Sex == 'male':
          return round(age_train_mean['male'])
    if x.Sex == 'female':
          return round(age_train_mean['female'])
#補間を実行する
train_df.Age.fillna(train_df[train_df.Age.isnull()].apply(fillage, axis=1),inplace = True)
#Ageについて補間されたことを確認
train_df.describe()
```
{{< figure src="/image/train_hokan.png" title="trainデータのAgeの補間結果を確認" class="center" width="800" height="220" >}}
```python
#テスト用データのAgeについても同様に補間
age_test_mean = test_df.groupby('Sex').Age.mean() 
test_df.Age.fillna(test_df[test_df.Age.isnull()].apply(fillage,axis=1),inplace=True)
#テスト用データのFareには1件欠損存在するため、同様に平均値で補間
Fare_test_mean = test_df.groupby('Fare').Fare.mean() 
test_df.Fare.fillna(test_df.Fare.mean(),inplace=True)
#Fareについて補間されたことを確認
test_df.describe()
```
{{< figure src="/image/test_hokan.png" title="testデータのAgeの補間結果を確認" class="center" width="800" height="220" >}}
```python
#Femaleカラムを追加し、Sex要素のmale/femaleを1/0に変換して、要素として追加する
train_df['Female'] = train_df['Sex'].map( {'male': 0, 'female': 1} ).astype(int)
test_df['Female'] = test_df['Sex'].map( {'male': 0, 'female': 1} ).astype(int)

#不要なカラムを落として、ロジスティック回帰にてFittingを実施
X = train_df.drop(['PassengerId','Name','Sex','Ticket','Cabin','Survived','Embarked'], axis = 1)
y = train_df.Survived

cls = LogisticRegression()
cls.fit(X,y)
```
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=100,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=None, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
学習したモデルの精度を表示する。
```python
cls.score(X, y)
```
結果：0.7968574635241302

最後にテストデータから生存者を予測する。
```python
#テストデータから生存者を予測
test_df_d = test_df.drop(['PassengerId','Name','Sex','Ticket','Cabin','Embarked'], axis = 1)
test_predict = cls.predict(test_df_d)

#テスト結果とマージ
test_df_a = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/機械学習/非線形回帰/test.csv")
result_df = pd.DataFrame({'PassengerId': test_df_a['PassengerId'], 'Survived':np.array(test_predict)})
result_df
```
{{< figure src="/image/test_fit.png" title="testデータに対する生存者予想の結果" class="center" width="200" height="300" >}}




# 主成分分析

<講義内容サマリ>

多変量データの持つ構造をより少数個の指標に圧縮し、小さな次元の情報に要約することで、全体の把握が容易になる。そのためには各変数のもつ共通の要素を抜き出して要約をすれば良い。
このように、変数を加工し、そこから要約された情報を取り出す手法が主成分分析です。

主成分分析では、多変量データを統合し、新たな総合指標を作り出すための手法ですが、多くの変数に重み（ウェイト）をつけて少数の合成変数（主成分）を作成する。情報の量を分散の大きさと捉え、線形変換後の変数の分散が最大となるような射影軸を探索する。

`$$
\begin{eqnarray*}
 \boldsymbol{s}_j &=& (s_{1j}, s_{2j}, \cdots, s_{nj})^T = \bar{X} \boldsymbol{a}_j  \\ 
\boldsymbol{a}_j &\in& \mathbb{R}^m \\
\end{eqnarray*}
$$`

探索には、制約（ノルムが1）付き最適化問題を解くが、ラグランジュ関数を最大にする係数ベクトルを探索する（微分して0となる点）。
ラグランジュ関数を微分して最適解を求めていくが、元データの分散共分散行列の固有値と固有ベクトルが、制約付き最適化問題の解となる。


<実装演習結果>
```python
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegressionCV
from sklearn.metrics import confusion_matrix
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
%matplotlib inline

cancer_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/機械学習/data/cancer.csv')
cancer_df.drop('Unnamed: 32', axis=1, inplace=True)
```
説明変数を3列目以降、目的変数を2列目（診断結果：良性B/悪性M）とする。
```python
# 目的変数の抽出
y = cancer_df.diagnosis.apply(lambda d: 1 if d == 'M' else 0)
# 説明変数の抽出
X = cancer_df.loc[:, 'radius_mean':]

# 学習用とテスト用でデータを分離
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

# 標準化
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# ロジスティック回帰で学習
logistic = LogisticRegressionCV(cv=10, random_state=0)
logistic.fit(X_train_scaled, y_train)

# 検証
print('Train score: {:.3f}'.format(logistic.score(X_train_scaled, y_train)))
print('Test score: {:.3f}'.format(logistic.score(X_test_scaled, y_test)))
print('Confustion matrix:\n{}'.format(confusion_matrix(y_true=y_test, y_pred=logistic.predict(X_test_scaled))))
```
Train score: 0.988
Test score: 0.972
Confustion matrix:
[[89  1]
 [ 3 50]]

検証スコア97%で分類できることを確認した。
主成分分析としてPCAオブジェクトを生成し、次元数を2まで削減する。
```python
# PCA
# 次元数2まで圧縮
pca = PCA(n_components=2)
X_train_pca = pca.fit_transform(X_train_scaled)
print('X_train_pca shape: {}'.format(X_train_pca.shape))
# X_train_pca shape: (426, 2)

# 寄与率
print('explained variance ratio: {}'.format(pca.explained_variance_ratio_))
# explained variance ratio: [ 0.43315126  0.19586506]

# 散布図にプロット
temp = pd.DataFrame(X_train_pca)
temp['Outcome'] = y_train.values
b = temp[temp['Outcome'] == 0]
m = temp[temp['Outcome'] == 1]
plt.scatter(x=b[0], y=b[1], marker='o') # 良性は○でマーク
plt.scatter(x=m[0], y=m[1], marker='^') # 悪性は△でマーク
plt.xlabel('PC 1') # 第1主成分をx軸
plt.ylabel('PC 2') # 第2主成分をy軸
```
{{< figure src="/image/pca_rlt.png" title="主成分分析による可視化の結果" class="center" width="600" height="400" >}}

PCAは教師なし学習であり、適切な主成分を見つけるタイミングで、教師データであるクラス情報を使わない。特徴量間の相関を見ているのみである。


# アルゴリズム

<サマリ>

#### k近傍法
k近傍法とは、クラスタ分析手法の1つであり、与えられた学習データをプロットしておき、未知のデータに対して距離が近い順に任意のk個を取得し、その多数決でデータが属するクラスを推定するもの。k近傍法には、近傍点の数・データポイント間の距離、という2つの重要なパラメータがある。説明変数が多い場合は、学習速度が遅くなる傾向があるため、次元削減等のデータ前処理が必要な場合がある。

<実装演習結果>
```python
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
 
X, y = mglearn.datasets.make_forge()
 
# train_test_splitで分割する
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
 
# インスタンスの生成、3つの近傍点で投票を行う
clf = KNeighborsClassifier(n_neighbors=3)
 
# 学習する
clf.fit(X_train, y_train)
```
どのような分類がされたかについて、確認をする。
```python
fig, axes = plt.subplots(1, 3, figsize=(10, 3))
 
for n_neighbors, ax in zip([1, 3, 9], axes):
    clf = KNeighborsClassifier(n_neighbors=n_neighbors).fit(X, y)
    # plot_2d_separator: 色で二分割
    mglearn.plots.plot_2d_separator(clf, X, fill=True, eps=0.5, ax=ax, alpha=.4)
    # discrete_scatter: 要素を分布
    mglearn.discrete_scatter(X[:, 0], X[:, 1], y, ax=ax)
    ax.set_title("{} neighbor(s)".format(n_neighbors))
    ax.set_xlabel("feature 0")
    ax.set_ylabel("feature 1")
axes[0].legend(loc=3)
plt.show()
```
{{< figure src="/image/k-kinbou.png" title="k-means法によるクラスタ分析の結果" class="center" width="1000" height="200" >}}

#### k-means法
k-means法は教師なし学習のクラスタ分析手法の1つで、最も広く用いられているクラスタリング手法の1つである。k-meansは任意にポイントした重心からの距離によってクラスタリングを実施する。
* アルゴリズム 
  * 各クラスタ中心の初期値を設定する
  * 各データ点に対して、各クラスタ中心との距離を計算し、最も距離が近いクラスタを割り当てる。
  *	各クラスタの平均ベクトル（中心）を計算する
  * 収束するまで上記の処理を繰り返し実施する

<実装演習結果>
scikit learnにて、クラスタリング用のデータを作成する。
```python
#!pip install mglearn
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import mglearn

X, y = make_blobs(random_state= 10)
```
クラスタセンタを2と4に指定して、クラスタに分割した結果を表示する。
```python
fig, axes = plt.subplots(1, 2, figsize = (10, 5))

#クラスタセンサを2つに指定
kmeans = KMeans(n_clusters=2)
kmeans.fit(X)
assignments = kmeans.labels_

mglearn.discrete_scatter(X[: , 0], X[: , 1],assignments, ax =axes[0])

#クラスタセンサを4つに指定
kmeans = KMeans(n_clusters=4)
kmeans.fit(X)
assignments = kmeans.labels_

mglearn.discrete_scatter(X[: , 0], X[: , 1],assignments, ax =axes[1])
```
{{< figure src="/image/k-means.png" title="k-means法によるクラスタ分析の結果" class="center" width="1000" height="300" >}}


# サポートベクタマシン

<サマリ>

サポートベクタマシンでは、正しい分類基準を見つけるために、「マージン最大化」という考え方を用いる。マージンとは、「判別する境界とデータの距離」のことを言う。なお、境界線と最も近くにあるデータを「サポートベクタ」と呼ぶ。このサポートベクタとのマージンを最大化するように境界を引き、クラスタ分類を行う。サポートベクタ以外のデータの値が多少変化したとしても、分類のための境界線の位置は一切変わらない。SVMは様々なkでーたセットに対してうまく機能するモデルであり、データにわずかな特徴量しかない場合でも、複雑な境界を生成することが可能。

#### カーネルトリック(kernel trick)
カーネルトリックとは、特徴空間中のデータ座標の明示的なけいさんを経由せずに、特徴空間い置ける関係性をデータから直接計算する手段を与える。つまり、かネールトリックを使うことで、明示的な座標の計算を経るよりもしばしば計算量が少なくて住むようになる。

* サポートベクタマシーン（SVM）のscikit-learnでの扱い
  * SVC：SVM Classification(分類問題に適用する)
  * SVR：SVM Regression(回帰問題に適用する)

* サポートベクタマシーンのデメリット
  * データの前処理とパラメータチューニングを注意深くする必要がある
  * 予測結果の検証が困難（予測結果に対する説明が難しい）

<実装演習結果>
scikit learnにて、クラスタリング用のデータを作成する。
```python
!pip install mglearn
from sklearn.datasets import make_blobs
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import mglearn

X, y = make_blobs(centers = 4, random_state = 8)
y = y % 2

mglearn.discrete_scatter(X[:, 0],X[: , 1], y)
plt.xlabel("Feature 0")
plt.ylabel("Feature 1")
```
{{< figure src="/image/svm1.png" title="分類用テストデータ" class="center" width="450" height="300" >}}

まずは線形にてクラスタ分類を試みる。
```python
from sklearn.svm import LinearSVC
linear_svn = LinearSVC().fit(X, y)

mglearn.plots.plot_2d_separator(linear_svn, X)
mglearn.discrete_scatter(X[:, 0],X[: , 1], y)
plt.xlabel("Feature 0")
plt.ylabel("Feature 1")
```
{{< figure src="/image/svm2.png" title="分類用テストデータを線形にて分類した結果" class="center" width="450" height="300" >}}
全くクラスタ分類できていないことがわかる。
このままでは分離ができないため、入力特徴量を拡張子、3次元のデータへと拡張子、サポートベクタマシーンにて評価する。
```python
X_new = np.hstack([X, X[:, 1:] ** 2])

from mpl_toolkits.mplot3d import Axes3D, axes3d

figure = plt.figure()
ax = Axes3D(figure, elev = -152, azim = -26)
mask = y == 0

ax.scatter(X_new[mask, 0],X_new[mask, 1],X_new[mask, 2],)
ax.scatter(X_new[~mask, 0],X_new[~mask, 1],X_new[~mask, 2],)
ax.set_xlabel("feature0")
ax.set_ylabel("feature1")
ax.set_zlabel("feature1 ** 2")
```
{{< figure src="/image/svm3.png" title="分類用テストデータを3次元に拡張" class="center" width="450" height="300" >}}
```python
linear_svm_3d = LinearSVC().fit(X_new, y)
coef, intercept = linear_svm_3d.coef_.ravel(), linear_svm_3d.intercept_

figure = plt.figure()
ax = Axes3D(figure, elev = -152, azim = -26)
xx = np.linspace(X_new[:, 0].min() - 2, X_new[:, 0].max()+ 2 , 50)
yy = np.linspace(X_new[:, 1].min() - 2, X_new[:, 1].max()+ 2 , 50)

XX, YY = np.meshgrid(xx, yy)
ZZ = (coef[0] * XX + coef[1] * YY + intercept) / -coef[2]
ax.plot_surface(XX, YY, ZZ, rstride = 8, cstride = 8, alpha = 0.3)

ax.scatter(X_new[mask, 0],X_new[mask, 1],X_new[mask, 2],)
ax.scatter(X_new[~mask, 0],X_new[~mask, 1],X_new[~mask, 2],)
ax.set_xlabel("feature0")
ax.set_ylabel("feature1")
ax.set_zlabel("feature1 ** 2")
```
{{< figure src="/image/svm4.png" title="3次元に拡張したデータにSVMを適用した結果" class="center" width="450" height="300" >}}
2次元では線形分離できなかったデータを3次元に拡張することで、SVMを使用して線形モデル（平面）にて分離することが可能となった。最後に、線形モデルを3次元に適用した結果を2次元に落として決定境界を描写する。
```python
ZZ = YY ** 2
dec = linear_svm_3d.decision_function(np.c_[XX.ravel(), YY.ravel(), ZZ.ravel()])
plt.contourf(XX, YY, dec.reshape(XX.shape), levels=[dec.min(), 0, dec.max()], cmap=mglearn.cm2, alpha = 0.5)
mglearn.discrete_scatter(X[:, 0], X[: , 1], y)
ax.set_xlabel("feature0")
ax.set_ylabel("feature1")
```
{{< figure src="/image/svm5.png" title="2次元上での決定境界" class="center" width="750" height="300" >}}